<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Povnuj MapCZ</title>
    
    <!-- Mapy.cz API -->
    <script type="text/javascript" src="https://api.mapy.cz/loader.js"></script>
    
    <!-- SortableJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; height: 100vh; overflow: hidden; display: flex; flex-direction: column; background: #fff; }
        
        #map-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; display: none; background: #eee; }
        #close-map-btn { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: #34495e; color: white; padding: 12px 24px; border-radius: 30px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); z-index: 30; display: none; font-weight: 600; cursor: pointer; align-items: center; gap: 8px; }

        #main-view { display: flex; flex-direction: column; height: 100vh; padding: 20px; padding-bottom: 70px; box-sizing: border-box; background: #fff; z-index: 10; }

        .header { margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; height: 50px; }
        .header-title-group { display: flex; align-items: center; gap: 10px; }
        h2 { margin: 0; font-size: 22px; color: #333; font-weight: 700; }
        .count-badge { background: #f0f0f0; padding: 4px 10px; border-radius: 12px; font-size: 14px; font-weight: bold; color: #555; }
        
        #header-stats { display: none; flex-direction: column; align-items: flex-end; justify-content: center; background: #e1f5fe; padding: 6px 12px; border-radius: 8px; }
        #header-stats.loading { opacity: 0.5; }
        .stat-time { font-size: 15px; font-weight: 700; color: #0277bd; line-height: 1.2; }
        .stat-dist { font-size: 12px; font-weight: 500; color: #546e7a; }

        .input-row { display: flex; gap: 10px; margin-bottom: 15px; }
        .input-wrapper { position: relative; flex-grow: 1; }
        input[type="text"] { width: 100%; padding: 16px; border: 2px solid #eee; border-radius: 12px; font-size: 16px; box-sizing: border-box; background: #fbfbfb; transition: border 0.2s; }
        input:focus { border-color: #3498db; outline: none; background: #fff; }

        #geo-btn { width: 56px; flex-shrink: 0; background: #eaf2f8; color: #3498db; border: 2px solid #d4e6f1; border-radius: 12px; cursor: pointer; font-size: 24px; display: flex; align-items: center; justify-content: center; padding: 0; margin: 0; }
        #geo-btn:active { background: #d4e6f1; }
        .spinner { border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        button { border: none; border-radius: 12px; padding: 16px; font-size: 16px; font-weight: 700; cursor: pointer; width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; margin-bottom: 10px; }
        .action-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: auto; margin-bottom: 10px; }
        #add-btn { background: #e8f5e9; color: #27ae60; margin-bottom: 20px; }
        #add-btn:active { background: #c8e6c9; }
        #sort-btn { background: #fef9e7; color: #f39c12; margin: 0; }
        #map-btn { background: #eaf2f8; color: #3498db; margin: 0; }
        #clear-btn { background: #ffebee; color: #e74c3c; margin: 0; }
        #clear-btn:active { background: #ffcdd2; }
        #nav-btn { background: #e74c3c; color: white; margin-top: 10px; box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3); margin-bottom: 0; }
        #nav-btn:active { transform: scale(0.98); }

        #address-list { list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto; margin-bottom: 20px; 
            /* ‚úÖ –í–∏–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –¥–ª—è –º–æ–±—ñ–ª—å–Ω–æ–≥–æ —Å–∫—Ä–æ–ª—É */ 
            -webkit-overflow-scrolling: touch;
        }
        #address-list li { 
            padding: 12px 10px; 
            border-bottom: 1px solid #f5f5f5; 
            display: flex; 
            align-items: center; 
            font-size: 16px; 
            background: #fff;
            min-height: 52px;
            position: relative;
            /* ‚úÖ –ü—Ä–∏–±—Ä–∞–Ω–æ touch-action –¥–ª—è –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ —Å–∫—Ä–æ–ª—É */
        }
        
        /* ‚úÖ –ü–æ–∑–Ω–∞—á–µ–Ω–Ω—è –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤ */
        #address-list li.duplicate {
            background: #fff3cd;
            border-left: 4px solid #ff9800;
        }
        
        .duplicate-badge {
            position: absolute;
            top: 5px;
            right: 40px;
            background: #ff9800;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .sortable-ghost { opacity: 0.4; background: #e3f2fd; }
        .sortable-drag { background: #fff; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }

        .handle {
            color: #bbb;
            cursor: grab;
            font-size: 20px;
            margin-right: 10px;
            padding: 5px;
            /* ‚úÖ –¢—ñ–ª—å–∫–∏ handle –º–∞—î touch-action: none */
            touch-action: none;
            align-self: flex-start;
        }

        .badge { background: #f0f0f0; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: bold; margin-right: 12px; color: #555; flex-shrink: 0; align-self: flex-start; }
        
        .text { 
            flex-grow: 1; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow: hidden;
            line-height: 1.3;
        }
        
        .city-name {
            font-weight: 600;
            font-size: 15px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .address-detail {
            font-size: 12px;
            color: #888;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }
        
        .del { color: #e74c3c; padding: 10px; font-size: 22px; cursor: pointer; align-self: flex-start; }
        
        .empty-state { text-align: center; color: #999; margin-top: 50px; font-size: 15px; display: none; }
        .smap-suggest { z-index: 9999 !important; font-size: 16px !important; }

        #chunks-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 100; display: none; align-items: center; justify-content: center; }
        #chunks-content { background: white; border-radius: 16px; padding: 20px; max-width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        #chunks-content h3 { margin: 0 0 15px 0; font-size: 20px; color: #333; }
        .chunk-item { background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .chunk-info { flex-grow: 1; }
        .chunk-title { font-weight: 700; font-size: 16px; color: #333; margin-bottom: 5px; }
        .chunk-details { font-size: 13px; color: #666; }
        .chunk-btn { background: #27ae60; color: white; border: none; padding: 10px 20px; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 14px; }
        .chunk-btn:active { background: #229954; }
        .chunk-btn.launched { background: #95a5a6; pointer-events: none; }
        .modal-actions { display: flex; gap: 10px; margin-top: 15px; }
        .modal-btn { flex: 1; padding: 14px; border-radius: 10px; border: none; font-weight: 700; cursor: pointer; }
        .modal-btn-primary { background: #e74c3c; color: white; }
        .modal-btn-secondary { background: #ecf0f1; color: #333; }
        
        .loading-indicator { text-align: center; padding: 20px; color: #666; }
        .loading-spinner { display: inline-block; width: 30px; height: 30px; border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 10px auto; }
    </style>
</head>
<body>

    <div id="map-container"></div>
    <div id="close-map-btn" onclick="closeMap()"><span>‚úï</span> –ó–∞–∫—Ä–∏—Ç–∏ –∫–∞—Ä—Ç—É</div>

    <div id="chunks-modal">
        <div id="chunks-content">
            <h3>üó∫Ô∏è –†–æ–∑–±–∏—Ç—Ç—è –º–∞—Ä—à—Ä—É—Ç—É</h3>
            <div id="chunks-list"></div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-primary" onclick="launchAllChunks()">üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç–∏ –≤—Å—ñ</button>
                <button class="modal-btn modal-btn-secondary" onclick="closeChunksModal()">–ó–∞–∫—Ä–∏—Ç–∏</button>
            </div>
        </div>
    </div>

    <div id="main-view">
        <div class="header">
            <div class="header-title-group">
                <h2>–ú—ñ–π –º–∞—Ä—à—Ä—É—Ç</h2>
                <span class="count-badge" id="count">0</span>
            </div>
            <div id="header-stats">
                <div class="stat-time" id="stat-time">--:--</div>
                <div class="stat-dist" id="stat-dist">-- –∫–º</div>
            </div>
        </div>

        <div class="input-row">
            <div class="input-wrapper">
                <input type="text" id="address-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –∞–¥—Ä–µ—Å—É..." autocomplete="off" />
            </div>
            <button id="geo-btn" onclick="addCurrentLocation()">
                <span id="geo-icon">üìç</span>
                <div id="geo-spinner" class="spinner"></div>
            </button>
        </div>

        <button id="add-btn" onclick="addAddress()">‚ûï –î–æ–¥–∞—Ç–∏ —Ç–æ—á–∫—É</button>

        <ul id="address-list"></ul>

        <div class="action-grid">
            <button id="sort-btn" onclick="optimizePointsOrder()">üîÉ –°–æ—Ä—Ç—É–≤–∞—Ç–∏</button>
            <button id="clear-btn" onclick="clearAllPoints()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç–∏</button>
            <button id="map-btn" onclick="openMap()">üó∫ –ù–∞ –∫–∞—Ä—Ç—É</button>
        </div>

        <button id="nav-btn" onclick="startNavigationApp()">üöÄ –ü–û–á–•–ê–õ–ò</button>
    </div>

    <script type="text/javascript">
        let m, routeLayer, markerLayer;
        let points = [];
        let suggest;
        let mapInitialized = false;
        let lastSuggestedCoords = null;
        let sortable; 
        let routeChunks = [];
        let chunkStats = [];
        let routeCalculationTimeout = null;

        const STORAGE_KEY = 'mapczRoutePoints';

        function parseAddress(fullAddress) {
            if (!fullAddress || fullAddress.trim() === '') {
                return {
                    city: '–ù–µ–≤—ñ–¥–æ–º–∞ –∞–¥—Ä–µ—Å–∞',
                    address: ''
                };
            }
            
            const parts = fullAddress.split(',').map(s => s.trim());
            
            if (parts.length >= 2) {
                let city = parts[1];
                let address = parts[0];
                
                if (parts.length >= 3 && /^\d{3}\s?\d{2}$/.test(parts[2])) {
                    address += ', ' + parts[2];
                }
                
                return {
                    city: city,
                    address: address
                };
            } else {
                return {
                    city: fullAddress,
                    address: ''
                };
            }
        }

        // ‚úÖ –§–£–ù–ö–¶–Ü–Ø –¥–ª—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤
        function findDuplicates() {
            const duplicates = new Set();
            const seen = new Map();
            
            points.forEach((p, index) => {
                // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∑ —Ç–æ—á–Ω—ñ—Å—Ç—é –¥–æ 4 –∑–Ω–∞–∫—ñ–≤
                const key = `${p.coords.x.toFixed(4)},${p.coords.y.toFixed(4)}`;
                
                if (seen.has(key)) {
                    duplicates.add(index);
                    duplicates.add(seen.get(key));
                } else {
                    seen.set(key, index);
                }
            });
            
            return duplicates;
        }

        function savePointsToStorage() {
            try {
                const simplePoints = points.map(p => ({
                    x: p.coords.x,
                    y: p.coords.y,
                    label: p.label
                }));
                localStorage.setItem(STORAGE_KEY, JSON.stringify(simplePoints));
                console.log('‚úÖ –¢–æ—á–∫–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–æ –≤ localStorage');
            } catch (e) {
                console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è:', e);
            }
        }

        function loadPointsFromStorage() {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                if (stored) {
                    const simplePoints = JSON.parse(stored);
                    points = simplePoints.map(p => ({
                        coords: SMap.Coords.fromWGS84(p.x, p.y),
                        label: p.label
                    }));
                    console.log(`‚úÖ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ ${points.length} —Ç–æ—á–æ–∫ –∑ localStorage`);
                    renderList();
                    if (points.length >= 2) {
                        calculateRouteStats();
                    }
                }
            } catch (e) {
                console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:', e);
                points = [];
            }
        }

        function clearAllPoints() {
            if (points.length === 0) {
                alert('–°–ø–∏—Å–æ–∫ –≤–∂–µ –ø–æ—Ä–æ–∂–Ω—ñ–π!');
                return;
            }
            
            if (confirm(`–í–∏–¥–∞–ª–∏—Ç–∏ –≤—Å—ñ ${points.length} —Ç–æ—á–æ–∫?\n–¶—è –¥—ñ—è –Ω–µ–∑–≤–æ—Ä–æ—Ç–Ω–∞!`)) {
                points = [];
                localStorage.removeItem(STORAGE_KEY);
                renderList();
                document.getElementById("header-stats").style.display = "none";
                console.log('üóëÔ∏è –í—Å—ñ —Ç–æ—á–∫–∏ –≤–∏–¥–∞–ª–µ–Ω–æ');
                
                if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
            }
        }

        function init() {
            const input = document.getElementById("address-input");
            
            suggest = new SMap.Suggest(input, {
                provider: new SMap.SuggestProvider({
                    updateParams: params => { params.count = 5; params.lang = 'uk'; }
                })
            });
            
            suggest.addListener("suggest", (suggestData) => {
                const data = suggestData.data;
                lastSuggestedCoords = SMap.Coords.fromWGS84(data.longitude, data.latitude);
                
                setTimeout(() => {
                    new SMap.Geocoder.Reverse(lastSuggestedCoords, (geocoder) => {
                        const results = geocoder.getResults();
                        
                        if (results && results.label) {
                            input.value = results.label;
                            console.log('‚úÖ –û–Ω–æ–≤–ª–µ–Ω–æ —ñ–Ω–ø—É—Ç:', results.label);
                        }
                    });
                }, 100);
            });

            input.addEventListener("keypress", function(e) {
                if (e.key === "Enter") addAddress();
            });

            const list = document.getElementById('address-list');
            sortable = Sortable.create(list, {
                handle: '.handle',
                animation: 150,
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                // ‚úÖ –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –¥–ª—è –º–æ–±—ñ–ª—å–Ω–æ–≥–æ —Å–∫—Ä–æ–ª—É
                delay: 200,
                delayOnTouchOnly: true,
                touchStartThreshold: 5,
                forceFallback: false,
                scroll: true,
                scrollSensitivity: 100,
                scrollSpeed: 10,
                bubbleScroll: true,
                onEnd: function (evt) {
                    const item = points.splice(evt.oldIndex, 1)[0];
                    points.splice(evt.newIndex, 0, item);
                    renderList(); 
                    savePointsToStorage();
                    calculateRouteStats();
                }
            });

            loadPointsFromStorage();
        }

        async function addAddress() {
            const input = document.getElementById("address-input");
            const val = input.value.trim();
            if (!val) return;

            let coords = null;
            let label = val;

            if (lastSuggestedCoords) {
                coords = lastSuggestedCoords;
                lastSuggestedCoords = null;
            } else {
                const res = await geocode(val);
                if (!res) return;
                coords = res.coords;
                label = res.label;
            }

            console.log('‚úÖ –î–æ–¥–∞—î–º–æ —Ç–æ—á–∫—É:', label);
            points.push({ coords, label });
            renderList();
            savePointsToStorage();
            input.value = "";
            
            if (points.length >= 2) {
                calculateRouteStats();
            } else {
                document.getElementById("header-stats").style.display = "none";
            }
        }

        function geocode(addr) {
            return new Promise(resolve => {
                new SMap.Geocoder(addr, g => {
                    const results = g.getResults()[0];
                    if (results && results.results && results.results.length > 0) {
                        const result = results.results[0];
                        let label = result.label || addr;
                        
                        resolve({ 
                            coords: result.coords, 
                            label: label
                        });
                    } else { 
                        alert("–ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ü—é –∞–¥—Ä–µ—Å—É"); 
                        resolve(null); 
                    }
                });
            });
        }

        function renderList() {
            const list = document.getElementById("address-list");
            list.innerHTML = "";
            
            // ‚úÖ –ó–Ω–∞—Ö–æ–¥–∏–º–æ –¥—É–±–ª—ñ–∫–∞—Ç–∏
            const duplicates = findDuplicates();
            
            points.forEach((p, i) => {
                const parsed = parseAddress(p.label);
                const li = document.createElement("li");
                
                // ‚úÖ –î–æ–¥–∞—î–º–æ –∫–ª–∞—Å —è–∫—â–æ –¥—É–±–ª—ñ–∫–∞—Ç
                if (duplicates.has(i)) {
                    li.classList.add('duplicate');
                }
                
                let addressHTML = `<div class="city-name">${parsed.city}</div>`;
                if (parsed.address) {
                    addressHTML += `<div class="address-detail">${parsed.address}</div>`;
                }
                
                // ‚úÖ –î–æ–¥–∞—î–º–æ –±–µ–π–¥–∂ —è–∫—â–æ –¥—É–±–ª—ñ–∫–∞—Ç
                const duplicateBadge = duplicates.has(i) ? '<span class="duplicate-badge">‚ö†Ô∏è –î–£–ë–õ–Ü–ö–ê–¢</span>' : '';
                
                li.innerHTML = `
                    <div class="handle">‚ò∞</div>
                    <div class="badge">${i+1}</div>
                    <div class="text">
                        ${addressHTML}
                    </div>
                    ${duplicateBadge}
                    <div class="del" onclick="removePoint(${i})">‚úï</div>
                `;
                list.appendChild(li);
            });

            document.getElementById("count").innerText = points.length;
        }

        function removePoint(i) {
            points.splice(i, 1);
            renderList();
            savePointsToStorage();
            
            if (points.length >= 2) {
                calculateRouteStats();
            } else {
                document.getElementById("header-stats").style.display = "none";
            }
        }

        function initMap() {
            const center = SMap.Coords.fromWGS84(15.4, 49.8);
            m = new SMap(document.getElementById("map-container"), center, 7);
            m.addDefaultLayer(SMap.DEF_BASE).enable();
            m.addDefaultControls();
            routeLayer = new SMap.Layer.Geometry(); m.addLayer(routeLayer); routeLayer.enable();
            markerLayer = new SMap.Layer.Marker(); m.addLayer(markerLayer); markerLayer.enable();
        }

        function openMap() {
            if (points.length === 0) return alert("–°–ø–æ—á–∞—Ç–∫—É –¥–æ–¥–∞–π—Ç–µ —Ç–æ—á–∫–∏!");
            document.getElementById("map-container").style.display = "block";
            document.getElementById("close-map-btn").style.display = "flex";
            if (!mapInitialized) { initMap(); mapInitialized = true; }
            calculateRoute();
        }

        function closeMap() {
            document.getElementById("map-container").style.display = "none";
            document.getElementById("close-map-btn").style.display = "none";
        }

        function calculateRoute(isBackground = false) {
            if (points.length < 2) return;
            const coords = points.map(p => p.coords);
            
            SMap.Route.route(coords, { geometry: true, criterion: 'short' }).then(route => {
                const results = route.getResults();
                updateStatsUI(results.length, results.time);

                if (!isBackground) {
                    if (!mapInitialized) { initMap(); mapInitialized = true; }
                    markerLayer.removeAll(); routeLayer.removeAll();
                    points.forEach((p, i) => {
                        markerLayer.addMarker(new SMap.Marker(p.coords, null, { title: `${i+1}` }));
                    });
                    routeLayer.addGeometry(new SMap.Geometry(SMap.GEOMETRY_POLYLINE, null, results.geometry));
                    const z = m.computeCenterZoom(coords);
                    m.setCenterZoom(z[0], z[1]);
                }
            });
        }

        function calculateRouteStats() {
            if (points.length < 2) {
                document.getElementById("header-stats").style.display = "none";
                return;
            }

            if (routeCalculationTimeout) {
                clearTimeout(routeCalculationTimeout);
            }

            const statsDiv = document.getElementById("header-stats");
            statsDiv.style.display = "flex";
            statsDiv.classList.add("loading");
            document.getElementById("stat-time").innerText = "...";
            document.getElementById("stat-dist").innerText = "...";

            routeCalculationTimeout = setTimeout(() => {
                const coords = points.map(p => p.coords);
                
                console.log('üîÑ –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –º–∞—Ä—à—Ä—É—Ç...');
                
                SMap.Route.route(coords, { geometry: true, criterion: 'fast' })
                    .then(route => {
                        const results = route.getResults();
                        console.log('‚úÖ –ú–∞—Ä—à—Ä—É—Ç —Ä–æ–∑—Ä–∞—Ö–æ–≤–∞–Ω–æ:', results);
                        updateStatsUI(results.length, results.time);
                        statsDiv.classList.remove("loading");
                    })
                    .catch(err => {
                        console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É:', err);
                        statsDiv.style.display = "none";
                        statsDiv.classList.remove("loading");
                    });
            }, 500);
        }

        function optimizePointsOrder() {
            if(points.length < 3) return alert("–¢—Ä–µ–±–∞ –º—ñ–Ω—ñ–º—É–º 3 —Ç–æ—á–∫–∏");
            let sorted = [points[0]], remaining = points.slice(1);
            while(remaining.length > 0) {
                let cur = sorted[sorted.length-1], nearest = -1, min = Infinity;
                remaining.forEach((p, i) => {
                    let d = cur.coords.distance(p.coords);
                    if(d < min) { min = d; nearest = i; }
                });
                sorted.push(remaining[nearest]);
                remaining.splice(nearest, 1);
            }
            points = sorted;
            renderList();
            savePointsToStorage();
            calculateRouteStats();
            if (navigator.vibrate) navigator.vibrate(50);
        }

        function updateStatsUI(meters, seconds) {
            const statsDiv = document.getElementById("header-stats");
            if (!meters || !seconds) { 
                statsDiv.style.display = "none"; 
                return; 
            }
            statsDiv.style.display = "flex";

            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const km = (meters / 1000).toFixed(1);

            let timeStr = "";
            if (h > 0) timeStr += `${h} –≥–æ–¥ `;
            timeStr += `${m} —Ö–≤`;
            
            document.getElementById("stat-time").innerText = timeStr;
            document.getElementById("stat-dist").innerText = `${km} –∫–º`;
        }

        function addCurrentLocation() {
            if (!navigator.geolocation) return alert("–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É –¥–æ GPS");
            const btnIcon = document.getElementById("geo-icon");
            const spinner = document.getElementById("geo-spinner");
            btnIcon.style.display = "none"; spinner.style.display = "block";

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const coords = SMap.Coords.fromWGS84(position.coords.longitude, position.coords.latitude);
                    new SMap.Geocoder.Reverse(coords, (geocoder) => {
                        const results = geocoder.getResults();
                        let label = results.label || `${coords.y.toFixed(5)}, ${coords.x.toFixed(5)}`;
                        
                        points.push({ coords: coords, label: "üìç " + label });
                        renderList();
                        savePointsToStorage();
                        btnIcon.style.display = "inline"; spinner.style.display = "none";
                        
                        if (points.length >= 2) {
                            calculateRouteStats();
                        }
                    });
                },
                (err) => { 
                    alert("GPS –ø–æ–º–∏–ª–∫–∞"); 
                    btnIcon.style.display = "inline"; spinner.style.display = "none"; 
                },
                { enableHighAccuracy: true }
            );
        }

        function startNavigationApp() {
            if (points.length < 2) return alert("–î–æ–¥–∞–π—Ç–µ –º—ñ–Ω—ñ–º—É–º 2 —Ç–æ—á–∫–∏!");
            
            if (points.length <= 17) {
                launchSingleRoute(points);
                return;
            }
            
            const modal = document.getElementById('chunks-modal');
            const list = document.getElementById('chunks-list');
            modal.style.display = 'flex';
            list.innerHTML = '<div class="loading-indicator"><div class="loading-spinner"></div><div>–†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –º–∞—Ä—à—Ä—É—Ç–∏...</div></div>';
            
            routeChunks = splitIntoChunks(points, 17);
            
            console.log(`üîÑ –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ ${routeChunks.length} —á–∞—Å—Ç–∏–Ω –º–∞—Ä—à—Ä—É—Ç—É...`);
            
            const promises = routeChunks.map((chunk, index) => {
                const coords = chunk.map(p => p.coords);
                console.log(`  –ß–∞—Å—Ç–∏–Ω–∞ ${index + 1}: ${chunk.length} —Ç–æ—á–æ–∫`);
                
                return SMap.Route.route(coords, { geometry: true, criterion: 'fast' })
                    .then(route => {
                        const results = route.getResults();
                        
                        console.log(`  ‚úÖ –ß–∞—Å—Ç–∏–Ω–∞ ${index + 1}:`, results);
                        
                        let distance = results.length || 0;
                        let time = results.time || 0;
                        
                        console.log(`  üìä ${(distance/1000).toFixed(1)} –∫–º, ${Math.round(time/60)} —Ö–≤`);
                        
                        return {
                            index: index,
                            distance: distance,
                            time: time,
                            launched: false
                        };
                    })
                    .catch(err => {
                        console.error(`  ‚ùå –ü–æ–º–∏–ª–∫–∞ –≤ —á–∞—Å—Ç–∏–Ω—ñ ${index + 1}:`, err);
                        return {
                            index: index,
                            distance: 0,
                            time: 0,
                            launched: false,
                            error: true
                        };
                    });
            });
            
            Promise.all(promises).then(stats => {
                chunkStats = stats;
                console.log('‚úÖ –í—Å—ñ —á–∞—Å—Ç–∏–Ω–∏ —Ä–æ–∑—Ä–∞—Ö–æ–≤–∞–Ω–æ:', chunkStats);
                showChunksModal();
            }).catch(err => {
                console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É:', err);
                list.innerHTML = '<div class="loading-indicator" style="color: #e74c3c;">‚ùå –ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É –º–∞—Ä—à—Ä—É—Ç—É</div>';
            });
        }

        function splitIntoChunks(points, maxPoints) {
            if (points.length <= maxPoints) {
                return [points];
            }
            
            const chunks = [];
            let i = 0;
            
            while (i < points.length) {
                const remainingPoints = points.length - i;
                
                if (remainingPoints <= maxPoints) {
                    chunks.push(points.slice(i));
                    break;
                } else {
                    chunks.push(points.slice(i, i + maxPoints));
                    i += maxPoints - 1;
                }
            }
            
            console.log('üîß –†–æ–∑–±–∏—Ç—Ç—è –Ω–∞ —á–∞—Å—Ç–∏–Ω–∏:');
            chunks.forEach((chunk, idx) => {
                console.log(`  –ß–∞—Å—Ç–∏–Ω–∞ ${idx + 1}: ${chunk.length} —Ç–æ—á–æ–∫`);
            });
            
            return chunks;
        }

        function showChunksModal() {
            const list = document.getElementById('chunks-list');
            
            list.innerHTML = '';
            
            let totalDist = 0;
            let totalTime = 0;
            
            routeChunks.forEach((chunk, i) => {
                const stats = chunkStats[i];
                
                if (!stats.error) {
                    totalDist += stats.distance;
                    totalTime += stats.time;
                }
                
                const km = (stats.distance / 1000).toFixed(1);
                const mins = Math.round(stats.time / 60);
                
                const startPoint = chunk[0].label.split(',')[0];
                const endPoint = chunk[chunk.length - 1].label.split(',')[0];
                
                const div = document.createElement('div');
                div.className = 'chunk-item';
                div.innerHTML = `
                    <div class="chunk-info">
                        <div class="chunk-title">–ß–∞—Å—Ç–∏–Ω–∞ ${i + 1} –∑ ${routeChunks.length}</div>
                        <div class="chunk-details">üìç ${chunk.length} —Ç–æ—á–æ–∫ | üöó ${km} –∫–º | ‚è±Ô∏è ${mins} —Ö–≤</div>
                        <div class="chunk-details" style="font-size: 11px; color: #999; margin-top: 3px;">${startPoint.substring(0, 25)}... ‚Üí ${endPoint.substring(0, 25)}...</div>
                    </div>
                    <button class="chunk-btn" id="chunk-btn-${i}" onclick="launchChunk(${i})">‚ñ∂ –ó–∞–ø—É—Å—Ç–∏—Ç–∏</button>
                `;
                list.appendChild(div);
            });
            
            const totalKm = (totalDist / 1000).toFixed(1);
            const totalH = Math.floor(totalTime / 3600);
            const totalM = Math.floor((totalTime % 3600) / 60);
            const totalTimeStr = totalH > 0 ? `${totalH} –≥–æ–¥ ${totalM} —Ö–≤` : `${totalM} —Ö–≤`;
            
            const summary = document.createElement('div');
            summary.style.cssText = 'background: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 10px; font-weight: 600; color: #27ae60;';
            summary.innerHTML = `üìä –ó–∞–≥–∞–ª–æ–º: ${totalKm} –∫–º, ${totalTimeStr}`;
            list.appendChild(summary);
        }

        function closeChunksModal() {
            document.getElementById('chunks-modal').style.display = 'none';
        }

        function launchChunk(index) {
            const chunk = routeChunks[index];
            const start = chunk[0].coords;
            const end = chunk[chunk.length - 1].coords;
            
            let url = `https://mapy.com/fnc/v1/route`;
            url += `?start=${start.x},${start.y}`;
            url += `&end=${end.x},${end.y}`;
            
            if (chunk.length > 2) {
                const waypoints = chunk.slice(1, -1)
                                      .map(p => `${p.coords.x},${p.coords.y}`)
                                      .join(';');
                url += `&waypoints=${waypoints}`;
            }
            
            url += `&routeType=car_fast_traffic`;
            url += `&navigate=true`;
            
            console.log(`=== –ó–ê–ü–£–°–ö –ß–ê–°–¢–ò–ù–ò ${index + 1} ===`);
            console.log(`URL: ${url}`);
            
            window.open(url, `_blank`);
            
            chunkStats[index].launched = true;
            const btn = document.getElementById(`chunk-btn-${index}`);
            btn.textContent = '‚úì –ó–∞–ø—É—â–µ–Ω–æ';
            btn.classList.add('launched');
            
            if (navigator.vibrate) navigator.vibrate(50);
        }

        function launchAllChunks() {
            for (let i = 0; i < routeChunks.length; i++) {
                setTimeout(() => {
                    launchChunk(i);
                }, i * 1500);
            }
        }

        function launchSingleRoute(routePoints) {
            const coords = routePoints.map(p => p.coords);
            
            SMap.Route.route(coords, { geometry: true, criterion: 'fast' }).then(route => {
                const results = route.getResults();
                
                const start = routePoints[0].coords;
                const end = routePoints[routePoints.length - 1].coords;
                
                let url = `https://mapy.com/fnc/v1/route`;
                url += `?start=${start.x},${start.y}`;
                url += `&end=${end.x},${end.y}`;
                
                if (routePoints.length > 2) {
                    const waypoints = routePoints.slice(1, -1)
                                          .map(p => `${p.coords.x},${p.coords.y}`)
                                          .join(';');
                    url += `&waypoints=${waypoints}`;
                }
                
                url += `&routeType=car_fast_traffic`;
                url += `&navigate=true`;
                
                console.log('=== –ó–ê–ü–£–°–ö –ú–ê–†–®–†–£–¢–£ ===');
                console.log(`–¢–æ—á–æ–∫: ${routePoints.length}`);
                console.log(`URL: ${url}`);
                
                window.open(url, '_blank');
                
                const distance = (results.length / 1000).toFixed(1);
                const time = Math.round(results.time / 60);
                
                alert(`‚úÖ –ù–∞–≤—ñ–≥–∞—Ü—ñ—è –∑–∞–ø—É—â–µ–Ω–∞!\n\nüöó –î–∏—Å—Ç–∞–Ω—Ü—ñ—è: ${distance} –∫–º\n‚è±Ô∏è –ß–∞—Å: ${time} —Ö–≤\nüìç –¢–æ—á–æ–∫: ${routePoints.length}`);
            });
        }

        Loader.load(null, { POI: true, suggest: true }, init);
    </script>
</body>
</html>
